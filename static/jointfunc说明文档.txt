测试用例说明：

    # 定义节点和边
    nodes = ['感冒', '头疼', '发烧']
    edges = {'感冒': ['头疼','发烧'], '头疼': ['感冒'], '发烧': ['感冒']}

    # 定义病症概率表（不考虑数据不合理性）
    probs = {'感冒': np.array([0.1, 0.9]), '头疼': np.array([[0.1, 0.9], [0.4, 0.6]]), '发烧': np.array([[0.1, 0.9], [0.5, 0.5]])}

probs['感冒']: 表示得到感冒的概率，是一个二元组，第一个元素为不得感冒的概率，第二个元素为得到感冒的概率。在这个例子中，概率为 (0.1, 0.9)，表示不得感冒的概率是 0.1，得到感冒的概率是 0.9。

probs['头疼']: 表示在得到或不得到感冒的情况下，出现头疼的概率。因此，它是一个2x2的矩阵。

probs['发烧']: 类似于 probs['头疼']，表示在得到或不得到感冒的情况下，出现发烧的概率。也是一个2x2的矩阵。


程序说明：
1.首先，导入了NumPy库，并定义了节点、边和概率表。这些信息用于构建联合树。

2.接下来，定义了一个名为JointTree的类，该类包含了联合树的相关方法，如构建联合树、计算节点的边缘概率和执行消息传递算法。

3.在JointTree类的初始化方法中，创建了一个空字典messages来存储节点之间的消息。对于每个节点，为其与邻居节点之间的消息设置初始概率，并将其存储在messages字典中。

4.然后，调用了message_passing()方法，该方法执行消息传递算法来更新节点之间的消息。

5.在计算节点的边缘概率时，首先将该节点的所有邻居节点的消息存储在一个列表中，并将它们相乘得到联合概率。然后将联合概率相加并归一化以得到边缘概率。

6.在message_passing()方法中，对于每个节点和其邻居节点，计算其它邻居节点发送的消息，并将它们相乘得到新消息。然后对新消息进行归一化，并计算与旧消息之间的差异。如果差异小于指定的容忍度，则停止迭代。否则，将新消息更新到messages字典中。

7.在主函数中，定义了节点、边和概率表，并创建了JointTree对象。然后调用marginal_prob()方法计算并输出了节点“发烧”的边缘概率。